import std/num/float64
import compiler/common/syntax
import compiler/common/name
import compiler/common/name-prim
import compiler/common/range
import compiler/type/type
import compiler/type/kind
import compiler/kind/kind
import newstd/data/linearset

fun isUnit(e: expr): bool
  match e
    Con(name) | name.getName == nameTuple(0) -> True
    _ -> False

fun isTrue(e: expr): bool
  match e
    Con(name) | name.getName == nameTrue -> True
    _ -> False

fun isFalse(e: expr): bool
  match e
    Con(name) | name.getName == nameFalse -> True
    _ -> False

val exprUnit = Con(TName(nameUnit, typeUnit), ConEnum(nameTpUnit, DataEnum, valueReprZero, 0))

val pEFalse = patExprBool(nameFalse, 0)
val patFalse = pEFalse.fst
val exprFalse = pEFalse.snd

val pETrue = patExprBool(nameTrue, 1)
val patTrue = pETrue.fst
val exprTrue = pETrue.snd

fun patExprBool(n: name, t: int): (pattern, expr)
  val tname = TName(n, typeBool)
  val conEnum = ConEnum(nameTpBool, DataEnum, valueReprZero, t)
  val conInfo = ConInfo(n, nameTpBool, [], [], [], TFun([], typeTotal, typeBool), Inductive, rangeNull, [], [], False, [], valueReprZero, Public, "")
  val pat = PatCon(tname, [], conEnum, [], [], typeBool, conInfo, False)
  val expr = Con(tname, conEnum)
  (pat, expr)

fun makeIfExpr(p: expr, t: expr, f: expr): expr
  Case([p], [Branch([patTrue], [Guard(exprTrue, t)]), Branch([patFalse], [Guard(exprFalse, f)])])

fun makeVector(tp: ktype, exprs: list<expr>): expr
  val a = TypeVar(0, kindStar, Bound)
  val vectorFromList = Var(TName(nameVector, TForAll([a], [], TFun([(nameNil, TApp(typeList, [TVar(a)]))], typeTotal, TApp(typeVector, [TVar(a)])))), InfoArity(1, 1))
  App(TypeApp(vectorFromList, [tp]), [makeList(tp, exprs)])

fun makeList(tp: ktype, exprs: list<expr>): expr
  val a = TypeVar(0, kindStar, Bound)
  val nilTp = TForAll([a], [], TApp(typeList, [TVar(a)]))
  val nilCon = Con(TName(nameNull, nilTp), ConSingleton(nameTpList, DataAsList, valueReprZero, 0))
  val nil = TypeApp(nilCon, [tp])
  val consTp = TForAll([a], [], TFun([(nameNil, TVar(a)), (nameNil, TApp(typeList, [TVar(a)]))], typeTotal, TApp(typeList, [TVar(a)])))
  val consCon = Con(TName(nameCons, consTp), ConAsCons(nameTpList, DataAsList, valueReprScan(2), nameNil, CtxNone, 2))
  fun cons(expr, xs)
    App(TypeApp(consCon, [tp]), [expr, xs])
  exprs.foldr(nil, cons)

fun makeDef(name: name, expr: expr): pure def
  Def(name, typeOf(expr), expr, Private, DefVal, InlineNever, rangeNull, "")

fun makeTDef(TName(name, tp): tName, expr: expr): pure def
  Def(name, tp, expr, Private, DefVal, InlineNever, rangeNull, "")

fun makeDefExpr(expr: expr)
  makeDef(nameNil, expr)

fun makeStats(l: list<expr>): pure expr
  match l
    Nil -> throw("core/core makeStats: no expression")
    Cons(e, Nil) -> e
    _ -> makeLet(l.init.map(fn(expr) DefNonRec(makeDef(nameNil, expr))), l.last.unjust)

fun makeDefsLet(defs0: list<def>, expr0: expr)
  fun make(defs, e)
    match defs
      Nil -> e
      Cons(def, rdefs) | e.isUnit && name(def:def) == nameNil && expr(def:def).isUnit -> make(rdefs, def.expr)
      _ -> makeLet(defs.reverse.map(DefNonRec), e)
  make(defs0.reverse, expr0)

//   This signifies that either a block
// if (is-unique(y)) { xUnique; free(y) } { xShared; xDecRef }
// or
// let ru = if (is-unique(y)) { xUnique; &y } { xShared; xDecRef; NULL }
// should be generated by reuse analysis after Parc.
// If this remains in the source after Reuse Analyis an error will be thrown!
fun makeDropSpecial(y: tName, xUnique: expr, xShared: expr, xDecRef: expr)
  val tp = TFun([y.typeOf, xUnique.typeOf, xShared.typeOf, xDecRef.typeOf].map(fn(t) (nameNil, t)), typeTotal, typeUnit)
  App(Var(TName(nameDropSpecial, tp), InfoExternal([])), [Var(y, InfoNone), xUnique, xShared, xDecRef])

struct core
  name: name
  imports: kimports
  fixDefs: fixDefs
  typeDefs: typeDefGroups
  defs: defGroups
  externals: externals
  doc: string;

alias fixDefs = list<fixDef>;
value type fixDef
  FixDef(name: name, fixity: fixity);

alias kimports = list<kimport>;
struct kimport
  name: name
  package: string
  visibility: visibility
  doc: string;

alias externals = list<external>;
type external
  External
    name: name
    typeScheme: ktype //scheme
    params: list<paramInfo>
    format: list<(target, string)>
    visibility: visibility
    range: range
    doc: string
  ExternalImport
    imports: list<(target,list<(string, string)>)>
    range: range

fun externalVis(e: external)
  match e
    External(visibility=v) -> v
    _ -> Private

pub fun externalImportLookup(t: target, b: buildType, key: string, e: external): maybe<string>
  match e
    ExternalImport(imports, _) ->
      val keys = match imports.find(fn(i) -> i.fst == t)
        Just(kv) -> kv.snd
        Nothing -> Nil
      b.eimportLookup(key, keys)
    _ -> Nothing

pub fun eimportLookup(b: buildType, s: string, ls: list<(string, string)>): maybe<string>
  val l = ls.find(fn(i) -> i.fst == s ++ "-" ++ b.show)
  match l
    Just(i) -> Just(i.snd)
    Nothing -> 
      match ls.find(fn(i) -> i.fst == s)
        Just(i) -> Just(i.snd)
        Nothing -> Nothing

pub fun lookupTarget(t: target, ims: list<(target, a)>): maybe<a>
  val tgs = match t
    C(WasmJs) -> [t, C(Wasm), C(CDefault) ,Default]
    C(WasmWeb) -> [t, C(Wasm), C(CDefault), Default]
    C(t1) -> [t, C(t1), Default]
    JS(_) -> [t, JS(JsDefault), Default]
    _ -> [t, Default]
  val r = tgs.map(fn(t1:target) ims.find(fn(t2) t2.fst == t1).map(fn(a) a.snd)).filter(fn(i) i.is-just)
  match r
    Cons(Just(x)) -> Just(x)
    _ -> Nothing

type typeDef
  Synonym(i: synInfo) // name, synonym info, and the visibility
  Data(info: dataInfo, isExtend: bool) //  name, info, visibility, and the visibilities of the constructors, the isExtend is true if this is an extension of the datatype.

alias typeDefGroups = list<typeDefGroup>
alias typeDefGroup = typeDefs
alias typeDefs = list<typeDef>

pub fun name(t: typeDef): name
  match t
    Synonym(info) -> info.name
    Data(info, _) -> info.name

pub fun isExtension(t: typeDef): bool
  match t
    Data(_, True) -> True
    _ -> False

pub fun vis(t: typeDef): visibility
  match t
    Synonym(info) -> info.vis
    Data(info, _) -> info.vis

fun flattenTypeDefGroups(tdgs:list<typeDefGroup>)
  tdgs.concat()

// Data representation
value type dataRepr
  DataEnum // only singletons (as an enumeration)
  DataIso // only one constructor with one field  (isomorpic)
  DataSingleStruct // only one constructor (no tag needed)
  DataStructAsMaybe // one constructor with one field, and one singleton (allows optimized boxed representation that avoids allocation)
  DataStruct // compatible constructors (all raw or regular types) and possibly singletons (need tag)
  // non-value types
  DataSingle(hasSingletons: bool) // only one constructor (no tag needed), hasSingletons true if it is a singleton as well
  DataAsMaybe // one constructor with one (non-recursive) field, and one singleton
  DataAsList // one constructor with fields, and one singleton (don't need a tag, for example can distinguish pointer vs enum)
  DataSingleNormal // one constructor with fields, and multiple singletons (distinguish one pointer vs enums)
  DataNormal(hasSingletons: bool)
  DataOpen;

type conRepr
  ConEnum(name: name, repr: dataRepr, valueRepr: valueRepr, tag: int) // part of enumeration (none has fields)
  ConIso(name: name, repr: dataRepr, valueRepr: valueRepr, tag: int) // one constructor with one field
  ConSingleton(name: name, repr: dataRepr, valueRepr: valueRepr, tag: int) // constructor without fields (and not part of an enum)
  ConSingle(name: name, repr: dataRepr, valueRepr: valueRepr, ctxPath: ctxPath, tag: int) // there is only one constructor and it is not iso or singleton (and this is it)
  ConAsJust(name: name, repr: dataRepr, valueRepr: valueRepr, asNothing: name, tag: int) // constructor is the just node of a maybe-like datatype  (only use for DataAsMaybe, not for DataStructAsMaybe)
  ConStruct(name: name, repr: dataRepr, valueRepr: valueRepr, tag: int) // constructor as value type
  ConAsCons(name: name, repr: dataRepr, valueRepr: valueRepr, asNil: name, ctxPath: ctxPath, tag: int) // constructor is the cons node of a list-like datatype  (may have one or more fields)
  ConOpen(name: name, repr: dataRepr, valueRepr: valueRepr, ctxPath: ctxPath) // constructor of open data type
  ConNormal(name: name, repr: dataRepr, valueRepr: valueRepr, ctxPath: ctxPath, tag: int); // a regular constructor

type ctxPath
  CtxNone
  CtxField(name: tName)

// Value data is not heap allocated and needs no header
fun hasCtxPath(repr: conRepr): bool
  repr.ctxPath.is-just

fun ctxPath(repr: conRepr): maybe<ctxPath>
  if repr.isValue then Nothing 
  else match repr
    ConSingle(ctxPath=cpath) -> Just(cpath)
    ConAsCons(ctxPath=cpath) -> Just(cpath)
    ConNormal(ctxPath=cpath) -> Just(cpath)
    ConOpen(ctxPath=cpath) -> Just(cpath)
    _ -> Nothing

fun scanCount(repr: conRepr)
  syntax/scanCount(repr.valueRepr)

fun allocSize(c: conRepr, p: platform)
  c.allocSizeScan(p).fst

fun allocSizeScan(c: conRepr, p: platform)
  val (size, scan) = p.sizeScan(c.valueRepr)
  if c.isValue then (0, scan) else (size, scan)

fun isValue(d: dataRepr): bool
  match d
    DataEnum -> True
    DataIso -> True
    DataSingleStruct -> True
    DataStructAsMaybe -> True
    DataStruct -> True
    _ -> False

fun needsTagField(d: dataRepr): bool
  match d
    DataStruct -> True
    DataStructAsMaybe -> True
    _ -> False

fun isValue(c: conRepr): bool
  c.repr.isValue

fun isValue(d: dataInfo): bool
  d.def.isValue

fun conRepr(d: dataInfo, c: conInfo)
  val (_, creprs) = d.dataRepr
  match d.constrs.zip(creprs).filter(fn((a, _)) a.name == c.name).map(snd)
    [crepr] -> crepr
    _ -> throw("core/core: conRepr: constructor not in the datatype")

fun dataRepr(i: dataInfo): exn (dataRepr, list<conRepr>)
  val typeName = i.name
  val conInfos = i.constrs
  val tags = list(0, conInfos.length - 1)
  val singletons = conInfos.filter(fn(c) c.params.is-nil)
  val hasExistentials = conInfos.any(fn(c) c.existentials.is-cons)
  val isValue = i.isValue && !i.isRec
  val (dataRepr, conReprFuns) = 
    if i.isRec then (DataOpen, conInfos.map(fn(ci) fn(ctag) ConOpen(typeName, DataOpen, ci.valueRepr, CtxNone)))
    elif conInfos.length == 1 then
      val conInfo = conInfos.head.unjust
      val dataRepr = 
        if isValue && conInfo.params.length == 1 then DataIso
        elif isValue && singletons.is-nil && !i.isRec then DataSingleStruct
        else DataSingle(singletons.is-cons)
      (dataRepr, [if isValue && conInfo.params.length == 1 then fn(tag) ConIso(typeName, dataRepr, conInfo.valueRepr, tag)
                  elif singletons.length == 1 then fn(tag) ConSingleton(typeName, dataRepr, conInfo.valueRepr, tag)
                  else fn(tag) ConSingle(typeName, dataRepr, conInfo.valueRepr, CtxNone, tag)])
    elif isValue && !i.isRec then
      val dataRepr = if conInfos.length == 2 && singletons.length == 1 && conInfos.filter(fn(c) c.params.length == 1).length == 1 then DataStructAsMaybe else DataStruct
      (dataRepr, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, dataRepr, c.valueRepr, tag) else fn(tag) ConStruct(typeName, dataRepr, c.valueRepr, tag)))
    else
      if conInfos.length == 2 && singletons.length == 1 then
        // note: for now we can only handle a true maybe type with a single Just constructor
        // with a parametric type so it is always kk_box_t at runtime.
        val maybeLike = match conInfos.filter(fn(c) c.params.length == 1)
          [cinfo] -> match cinfo.params
            [(_, TVar)] -> True // single field of type 'a
            _ -> False
          _ -> False
        if !i.isRec && maybeLike then
          (DataAsMaybe, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, DataAsMaybe, c.valueRepr, tag) else fn(tag) ConAsJust(typeName, DataAsMaybe, c.valueRepr, singletons.head.unjust.name, tag)))
        else (DataAsList, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, DataAsList, c.valueRepr, tag) else fn(tag) ConAsCons(typeName, DataAsList, c.valueRepr, singletons.head.unjust.name, CtxNone, tag)))
      else
        val dataRepr = if singletons.length == conInfos.length - 1 || conInfos.is-nil then DataSingleNormal else DataNormal(singletons.is-cons)
        (dataRepr, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, dataRepr, c.valueRepr, tag) else fn(tag) ConNormal(typeName, dataRepr, c.valueRepr, CtxNone, tag)))
  (dataRepr, conReprFuns.map-indexed(fn(index, c) c(index + 1)))


// Definition Groups
alias defGroups = list<defGroup>

fun flatten(dgs: list<defGroup>): list<def>
  dgs.map(fn(d) match d {DefRec(dfs) -> dfs; DefNonRec(d) -> [d]}).concat()

fun flatten(dgs: list<defGroups>): list<def>
  dgs.map(flatten).concat()

fun map(dg: defGroup, f: (def) -> e def): e defGroup
  match dg
    DefRec(defs) -> DefRec(defs.map(f))
    DefNonRec(def) -> DefNonRec(f(def))

type defGroup
  DefRec(defs: list<def>)
  DefNonRec(def: def)

// A value definition
struct def
  name: name
  t: ktype
  expr: expr
  vis: visibility // private public
  sort: defSort // fun / val / var
  kinline: defInline // auto / always, never
  nameRange: range
  doc: string;

struct inlineDef
  name: name
  expr: expr
  rec: bool
  kind: defInline
  cost: int
  sort: defSort // for borrow information
  paramSpecialize: list<bool>

fun isVal(d: def): bool
  !d.sort.is-defFun

fun paramInfos(d: def)
  match d.sort
    DefFun(i) -> i
    _ -> Nil

fun isSpecialize(inl: inlineDef)
  inl.paramSpecialize.is-cons

effect corePhase
  fun getUnique(): int
  fun setUnique(i: int): ()
  fun updateUnique(f: (int) -> e int): ()
  fun getCoreDefs(): defGroups
  fun setCoreDefs(): defGroups
  fun phaseError(s: string): a


// Expressions
// Since this is System-F, all binding sites are annotated with their type.
type expr
  // Core lambda calculus
  Lam(names: list<tName>, eff: ktype, e: expr)
  Var(name: tName, info: varInfo) // typed name and possible typeArity/parameter arity tuple for top-level functions
  App(f: expr, args: list<expr>) // always fully applied!
  TypeLam(args: list<typeVar>, e: expr) // Type (universal) abstraction/application
  TypeApp(f: expr, types: list<ktype>)
  // Literals, constants and labels
  Con(name: tName, repr: conRepr) // typed name and its representation
  ELit(lit: lit)
  // Let
  Let(defs: list<defGroup>, e: expr)
  // Case expressions
  Case(exprs: list<expr>, branches: list<branch>);

struct branch
  patterns: list<pattern> // length = length exprs in the match
  guards: list<guard>; // any number (>= 1) of guarded expressions

struct guard
  test: expr // boolean
  expr: expr; // bdoy of the branch

type pattern
  PatCon
    name: tName // names the constructor with full signature.
    pattern: list<pattern> // sub-patterns. fully materialized to match arity.
    pepr: conRepr // representation of ctor in backend.
    typeArgs: list<ktype> // zipped with patConPatterns
    kexists: list<typeVar> // closed under existentials here
    typeRes: ktype // result type
    info: conInfo // other constructor info
    skip: bool // skip testing for this constructor (as it should match already)
  PatVar(name: tName, pattern: pattern) // name / type of variable and named subpattern
  PatLit(lit: lit)
  PatWild

type lit
  LitInt(i: int)
  LitFloat(d: float64)
  LitChar(c: char)
  LitString(s: string)

type varInfo
  InfoNone
  InfoArity(t: int, p: int) // type parameters, parameters
  InfoExternal(b: list<(target, string)>) // inline body
  InfoReuse(p: pattern) 
  InfoConField(cName: tName, repr: conRepr, fName: tName) // constructor name, field name

value struct tName
  getName: name
  tNameType: ktype

fun show(name: tName): string
  name.getName.show

fun defTName(def: def): tName
  TName(def.name, def.t)

fun defsTNames(defs: list<def>): list<tName>
  defs.map(defTName)

fun defGroupTNames(dg: defGroup): list<tName>
  match dg
    DefRec(defs) -> defsTNames(defs)
    DefNonRec(def) -> [defTName(def)]

fun defGroupsTNames(dgs: list<defGroup>): list<tName>
  dgs.map(defGroupTNames).concat()

fun show(v: varInfo): string
  match v
    InfoNone -> ""
    InfoReuse -> "reuse:<pat>"
    InfoConField(n, _, fName) -> "field: " ++ n.show ++ "." ++ fName.show
    InfoArity(m, n) -> "arity:" ++ m.show ++ "," ++ n.show
    InfoExternal(b) -> "external:" ++ b.show-list(fn((t, s)) t.show ++ ":" ++ s)

fun airity(v: varInfo): int
  match v
    InfoArity(_, n) -> n
    _ -> 0

fun typeAirity(v: varInfo): int
  match v
    InfoArity(n, _) -> n
    _ -> 0

fun isLocal(i: varInfo): bool
  match i
    InfoNone -> True
    InfoReuse -> True
    _ -> False

fun isRefCounted(i: varInfo)
  i.isLocal

fun isTotal(e: expr): div bool
  match e
    Lam -> True
    Var -> True
    TypeLam(_, ex) -> ex.isTotal
    TypeApp(ex, _) -> ex.isTotal
    Con -> True
    ELit -> True
    Let(dgs, ex) -> dgs.flatten.all(isTotal) && ex.isTotal
    Case(exps, brnchs) -> exps.all(isTotal) && brnchs.all(isTotal)
    App(f, args) -> f.isTotal && args.all(isTotal)

fun isTotal(b: branch): div bool
  b.guards.all(isTotal)

fun isTotal(g: guard): div bool
  g.expr.isTotal

fun isTotalFun(e: expr): pure bool
  match e
    Lam(_, _, b) -> b.isTotal
    TypeLam(_, ex) -> ex.isTotalFun
    TypeApp(ex, _) -> ex.isTotalFun
    Con -> True
    ELit -> True
    Let(dgs, e) -> dgs.flatten.all(isTotal) && e.isTotalFun
    Case(exps, brnchs) -> exps.all(isTotalFun) && brnchs.all(isTotalFun)
    App(f, args) -> e.typeOf.hasTotalEffect && f.isTotalFun && args.all(isTotal)
    Var(v) -> v.getName == nameBox || v.getName == nameUnbox

fun isTotalFun(b: branch): pure bool
  b.guards.all(isTotalFun)

fun isTotalFun(g: guard): pure bool
  g.expr.isTotalFun

fun isTotal(d: def): div bool
  d.expr.isTotal

fun hasTotalEffect(tp: ktype): bool
  match tp.splitFunScheme
    Nothing -> False
    Just((_, _, _, eff, _)) -> eff.isTypeTotal

fun isMonType(tp: ktype): pure bool
  if tp.kind == kindEffect then tp.isMonEffect
  else match tp.expandSyn
    TForAll(_, _, t) -> t.isMonType
    TFun(_, eff, _) -> eff.isMonEffect
    _ -> False

fun isMonEffect(eff: ktype): pure bool
  val (ls, tl) = eff.extractEffectExtend
  !tl.isEffectEmpty || ls.any(fn(l) match l.getHandledEffect([]) {Just((ResumeMany, _)) -> True; _ -> False})

fun isInlineable(max: int, def: def): div bool
  match def.kinline
    InlineAlways -> True
    InlineNever -> False
    _ -> def.cost <= max

val costInf = 1000

fun cost(d: def): div int
  val n = d.costLocal
  if d.isVal then if n == 0 then 0 else costInf else n

fun costLocal(d: def): div int
  d.expr.cost

fun cost(dg: defGroup): div int
  match dg
    DefRec(defs) -> defs.map(cost).sum
    DefNonRec(def) -> cost(def)

fun cost(expr: expr): div int
  match expr
    Var(tname) | tname.getName.isHiddenExternalName -> costInf
    Lam(_, _, b) -> 0 + b.cost
    Var -> 0
    App(e, args) -> 1 + e.cost + args.map(cost).sum
    TypeLam(_, e) -> e.cost
    TypeApp(e, _) -> e.cost
    Con -> 0
    ELit -> 0
    Let(dgs, b) -> dgs.map(cost).sum + b.cost
    Case(exprs, branches) -> (branches.length - 1) + exprs.map(cost).sum + branches.map(cost).sum

fun cost(b: branch): div int
  b.guards.map(cost).sum

fun cost(g: guard): div int
  g.expr.cost

fun typeArity(e: expr): pure int
  e.typeOf.typeArities.fst

fun paramArity(e: expr): pure int
  e.typeOf.typeArities.snd

fun getEffect(e: expr): keffect
  match e
    Lam(_, eff, _) -> eff
    TypeLam(_, Lam(_, eff, _)) -> eff
    _ -> effectEmpty

// Generic traversals

fun foldMap(e: expr, acc: expr -> e ctx<a>): e ctx<a>
  match e
    Lam(_, _, b) -> acc(e) ++ foldMap(b, acc)
    Var -> acc(e)
    App(f, args) -> args.foldl(acc(e) ++ foldMap(f, acc), fn(s, a) s ++ acc(a))
    TypeLam(_, b) -> acc(e) ++ foldMap(b, acc)
    TypeApp(f, _) -> acc(e) ++ foldMap(f, acc)
    Con -> acc(e)
    ELit -> acc(e)
    Let(binders, body) -> binders.flatten.foldl(acc(e), fn(s, a) s ++ acc(a.expr)) ++ foldMap(body, acc)
    Case(cases, branches) -> branches.foldl(cases.foldl(acc(e), fn(s, a) s ++ acc(a)), fn(s, b) b.guards.foldl(s, fn(s', g) s' ++ acc(g.test) ++ acc(g.expr)))

effect efind
  final ctl found(e: expr): a

fun anySubExpr(e, f)
  with handler 
    final ctl found(ex) Just(ex)
    return(x) Nothing
  val c = ctx _
  e.foldMap(fn(a) if f(a) then found(e) else c)


// TODO: More here

// Type variables
val tnamesEmpty = linearSet([], fn(a, b) a.getName == b.getName, fn(a) a.show)
fun tnames(l: list<tName>): linearSet<tName>
  linearSet(l, fn(a, b) a.getName == b.getName, fn(a) a.show)

fun (>)(t1: tName, t2: tName): bool
  name/compare(t1.getName, t2.getName) == Gt

fun makeLet(defs: list<defGroup>, expr: expr): expr
  match defs
    Nil -> expr
    _ -> match expr
      Let(defs', body) -> Let(defs ++ defs', body)
      _ -> Let(defs, expr)

fun makeTypeApp(e: expr, l: list<ktype>): expr
  match l
    Nil -> e
    _ -> match e
      TypeApp(e, l') -> TypeApp(e, l ++ l')
      _ -> TypeApp(e, l)

fun addApps(l: list<expr>, e: expr)
  match l
    Nil -> e
    _ -> match e
      App(e, l') -> App(e, l ++ l')
      _ -> App(e, l)

fun addTypeApps(l: list<typeVar>, e: expr)
  match l
    Nil -> e
    _ -> match e
      TypeApp(e', l') -> TypeApp(e', l' ++ l.map(TVar))
      _ -> TypeApp(e, l.map(TVar))

fun addTypeLambdas(l: list<typeVar>, e: expr)
  match l
    Nil -> e
    _ -> match e
      TypeLam(l', e') -> TypeLam(l ++ l', e')
      _ -> TypeLam(l, e)

fun addLambdas(l: list<(name, ktype)>, effT: ktype, e: expr)
  match l
    Nil -> e
    _ -> match e
      Lam(l', _, e') -> Lam(l.map(fn((n, t)) TName(n, t)) ++ l', effT, e')
      _ -> Lam(l.map(fn((n, t)) TName(n, t)), effT, e)

fun addLambdas(l: list<tName>, effT: ktype, e: expr)
  match l
    Nil -> e
    _ -> match e
      Lam(l', _, e') -> Lam(l ++ l', effT, e')
      _ -> Lam(l, effT, e)

fun addNonRec(x: name, tp: ktype, e: expr, e': expr)
  Let([DefNonRec(Def(x, tp, e, Private, if e.isValue then DefVal else DefFun([]), InlineAuto, rangeNull, ""))], e')

fun isValue(e: expr): bool
  match e
    TypeLam(_, Lam) -> False
    Lam -> False
    _ -> True
// TODO: More here



fun typeOf(tname: tName): ktype
  tname.tNameType

fun typeOf(expr: expr): pure ktype
  match expr
    Lam(pars, eff, expr) -> TFun(pars.map(fn((TName(name, tp))) (name, tp)), eff, expr.typeOf)
    Var(tname) -> typeOf(tname)
    Con(tname) -> typeOf(tname)
    App(f, args) -> match f.typeOf.splitFunScheme
      Just((_, _, targs, eff, tres)) 
        | args.length == targs.length || targs.length == 0 -> tres
        | args.length > targs.length -> typeOf(App(Var(TName("tmp".newName, tres), InfoNone), args.drop(targs.length)))
        | True -> TFun(targs.drop(args.length), eff, tres)
      _ -> throw("core/core typeOf(App..) Expected function TODO: Show real type")
    TypeLam(xs, expr) -> TForAll(xs, [], expr.typeOf)
    TypeApp(expr, []) -> expr.typeOf
    // TypeApp(expr, tps) ->
    //   val (tvs, tp1) = expr.typeOf.splitTForall
    //   tvs.zip(tps).subNew(tp1)
    ELit(l) -> l.typeOf
    Let(_, expr) -> expr.typeOf
    Case(_, branches) -> branches.head.unjust.typeOf

fun typeOf(Branch(_, guards): branch): pure ktype
    match guards
      Cons(g, _) -> g.typeOf
      _ -> throw("core/core typeOf(Branch..) branch with no guards")

fun typeOf(Guard(_, expr): guard): pure ktype
  expr.typeOf

fun typeOf(l: lit): ktype
  match l
    LitInt(_) -> typeInt
    LitFloat(_) -> typeFloat
    LitChar(_) -> typeChar
    LitString(_) -> typeString
