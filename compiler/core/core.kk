import std/num/float64
import compiler/common/syntax
import compiler/common/name
import compiler/common/id
import compiler/common/name-prim
import compiler/common/range
import compiler/type/type
import compiler/type/kind
import compiler/kind/kind
import newstd/data/linearset
import compiler/common/name-collections

fun isUnit(e: expr): bool
  match e
    Con(tn) | tn.getName == nameTuple(0) -> True
    _ -> False

fun isTrue(e: expr): bool
  match e
    Con(tn) | tn.getName == nameTrue -> True
    _ -> False

fun isFalse(e: expr): bool
  match e
    Con(tn) | tn.getName == nameFalse -> True
    _ -> False

val exprUnit = Con(TName(nameUnit, typeUnit), ConEnum(nameTpUnit, DataEnum, valueReprZero, 0))

val pEFalse = patExprBool(nameFalse, 0)
val patFalse = pEFalse.fst
val exprFalse = pEFalse.snd

val pETrue = patExprBool(nameTrue, 1)
val patTrue = pETrue.fst
val exprTrue = pETrue.snd

fun patExprBool(n: name, t: int): (pattern, expr)
  val tn = TName(n, typeBool)
  val conEnum = ConEnum(nameTpBool, DataEnum, valueReprZero, t)
  val conInfo = ConInfo(n, nameTpBool, [], [], [], TFun([], typeTotal, typeBool), Inductive, rangeNull, [], [], False, [], valueReprZero, Public, "")
  val pat = PatCon(tn, [], conEnum, [], [], typeBool, conInfo, False)
  val expr = Con(tn, conEnum)
  (pat, expr)

fun makeIfExpr(p: expr, t: expr, f: expr): expr
  Case([p], [Branch([patTrue], [Guard(exprTrue, t)]), Branch([patFalse], [Guard(exprFalse, f)])])

fun makeVector(tp: ktype, exprs: list<expr>): expr
  val a = TypeVar(0, kindStar, Bound)
  val vectorFromList = Var(TName(nameVector, TForAll([a], [], TFun([(nameNil, TApp(typeList, [TVar(a)]))], typeTotal, TApp(typeVector, [TVar(a)])))), InfoArity(1, 1))
  App(TypeApp(vectorFromList, [tp]), [makeList(tp, exprs)])

fun makeList(tp: ktype, exprs: list<expr>): expr
  val a = TypeVar(0, kindStar, Bound)
  val nilTp = TForAll([a], [], TApp(typeList, [TVar(a)]))
  val nilCon = Con(TName(nameNull, nilTp), ConSingleton(nameTpList, DataAsList, valueReprZero, 0))
  val nil = TypeApp(nilCon, [tp])
  val consTp = TForAll([a], [], TFun([(nameNil, TVar(a)), (nameNil, TApp(typeList, [TVar(a)]))], typeTotal, TApp(typeList, [TVar(a)])))
  val consCon = Con(TName(nameCons, consTp), ConAsCons(nameTpList, DataAsList, valueReprScan(2), nameNil, CtxNone, 2))
  fun cons(e, xs)
    App(TypeApp(consCon, [tp]), [e, xs])
  exprs.foldr(nil, cons)

fun makeDef(nm: name, e: expr): pure def
  Def(nm, typeOf(e), e, Private, DefVal, InlineNever, rangeNull, "")

fun makeTDef(TName(nm, tp): tName, e: expr): pure def
  Def(nm, tp, e, Private, DefVal, InlineNever, rangeNull, "")

fun makeDefExpr(expr: expr)
  makeDef(nameNil, expr)

fun makeStats(l: list<expr>): pure expr
  match l
    Nil -> throw("core/core makeStats: no expression")
    Cons(e, Nil) -> e
    _ -> makeLet(l.init.map(fn(expr) DefNonRec(makeDef(nameNil, expr))), l.last.unjust)

fun makeDefsLet(defs0: list<def>, expr0: expr)
  fun make(defs, e)
    match defs
      Nil -> e
      Cons(d, rdefs) | e.isUnit && defName(d:def) == nameNil && defExpr(d:def).isUnit -> make(rdefs, d.defExpr)
      _ -> makeLet(defs.reverse.map(DefNonRec), e)
  make(defs0.reverse, expr0)

//   This signifies that either a block
// if (is-unique(y)) { xUnique; free(y) } { xShared; xDecRef }
// or
// let ru = if (is-unique(y)) { xUnique; &y } { xShared; xDecRef; NULL }
// should be generated by reuse analysis after Parc.
// If this remains in the source after Reuse Analyis an error will be thrown!
fun makeDropSpecial(y: tName, xUnique: expr, xShared: expr, xDecRef: expr)
  val tp = TFun([y.typeOf, xUnique.typeOf, xShared.typeOf, xDecRef.typeOf].map(fn(t) (nameNil, t)), typeTotal, typeUnit)
  App(Var(TName(nameDropSpecial, tp), InfoExternal([])), [Var(y, InfoNone), xUnique, xShared, xDecRef])

struct core
  coreName: name
  imports: kimports = []
  fixDefs: fixDefs = []
  typeDefs: typeDefGroups = []
  defs: defGroups = []
  externals: externals = []
  doc: string = ""

fun show(c: core): div string
  "Core(" ++ c.coreName.show ++ "," ++ c.imports.show-list(show) ++ "," ++ c.fixDefs.show-list(show) ++ 
  "," ++ c.typeDefs.show-list(fn(g) g.show-list(show)) ++ "," ++ c.defs.show-list(show) ++ "," ++ c.externals.show-list(show) ++ "," ++ c.doc.show ++ ")"

alias fixDefs = list<fixDef>;
value type fixDef
  FixDef(defName: name, f: fixity);

fun show(f: fixDef): string
  match f
    FixDef(defName, f') -> "FixDef(" ++ defName.show ++ "," ++ show(f') ++ ")"

alias kimports = list<kimport>;
struct kimport
  importName: name
  package: string
  visibility: visibility
  doc: string;

fun show(i: kimport): string
  "Kimport(" ++ i.importName.show ++ "," ++ i.package.show ++ "," ++ i.visibility.show ++ "," ++ i.doc.show ++ ")"

alias externals = list<external>;
type external
  External
    externName: name
    typeScheme: ktype //scheme
    params: list<paramInfo>
    format: list<(target, string)>
    visibility: visibility
    fipT: fipT
    rng: range
    doc: string
  ExternalImport
    imports: list<(target,list<(string, string)>)>
    rng: range

fun show(e: external): div string
  match e
    External(name, typeScheme, params, format, visibility, fipT, rng, doc) -> 
      "External(" ++ name.show ++ "," ++ typeScheme.show ++ "," ++ params.show-list(show) ++ "," ++ 
      format.show-list(fn(f) f.show-tuple(show, show)) ++ "," ++ visibility.show ++ "," ++ fipT.show ++ "," ++ rng.showFullRange ++ "," ++ doc.show ++ ")"
    ExternalImport(imports, rng) -> 
      "ExternalImport(" ++ imports.show-list(fn((t, ls)) t.show ++ ":" ++ ls.show-list(fn((s1, s2)) s1.show ++ ":" ++ s2.show)) ++ "," ++ rng.showFullRange ++ ")"

fun vis(e: external)
  match e
    External(visibility=v) -> v
    _ -> Private

pub fun externalImportLookup(t: target, b: buildType, key: string, e: external): maybe<string>
  match e
    ExternalImport(imports, _) ->
      val keys = match imports.find(fn(i) -> i.fst == t)
        Just(kv) -> kv.snd
        Nothing -> Nil
      b.eimportLookup(key, keys)
    _ -> Nothing

pub fun eimportLookup(b: buildType, s: string, ls: list<(string, string)>): maybe<string>
  val l = ls.find(fn(i) -> i.fst == s ++ "-" ++ b.show)
  match l
    Just(i) -> Just(i.snd)
    Nothing -> 
      match ls.find(fn(i) -> i.fst == s)
        Just(i) -> Just(i.snd)
        Nothing -> Nothing

pub fun lookupTarget(t: target, ims: list<(target, a)>): maybe<a>
  val tgs = match t
    C(WasmJs) -> [t, C(Wasm), C(CDefault) ,DefaultTarget]
    C(WasmWeb) -> [t, C(Wasm), C(CDefault), DefaultTarget]
    C(t1) -> [t, C(t1), DefaultTarget]
    JS(_) -> [t, JS(JsDefault), DefaultTarget]
    _ -> [t, DefaultTarget]
  val r = tgs.map(fn(t1:target) ims.find(fn(t2) t2.fst == t1).map(fn(a) a.snd)).filter(fn(i) i.is-just)
  match r
    Cons(Just(x)) -> Just(x)
    _ -> Nothing

type typeDef
  Synonym(i: synInfo) // name, synonym info, and the visibility
  Data(info: dataInfo, isExtend: bool) //  name, info, visibility, and the visibilities of the constructors, the isExtend is true if this is an extension of the datatype.

fun show(t: typeDef): string
  match t
    Synonym(i) -> "Synonym(" ++ i.show ++ ")"
    Data(i, b) -> "Data(" ++ i.show ++ "," ++ b.show ++ ")"

alias typeDefGroups = list<typeDefGroup>
alias typeDefGroup = typeDefs
alias typeDefs = list<typeDef>

pub fun name(t: typeDef): name
  match t
    Synonym(info) -> info.name
    Data(info, _) -> info.name

pub fun isExtension(t: typeDef): bool
  match t
    Data(_, True) -> True
    _ -> False

pub fun vis(t: typeDef): visibility
  match t
    Synonym(info) -> compiler/type/type/vis(info)
    Data(info, _) -> compiler/type/type/vis(info)

fun flatten(tdgs:list<typeDefGroup>): list<typeDef>
  tdgs.concat()

// Data representation
value type dataRepr
  DataEnum // only singletons (as an enumeration)
  DataIso // only one constructor with one field  (isomorpic)
  DataSingleStruct // only one constructor (no tag needed)
  DataStructAsMaybe // one constructor with one field, and one singleton (allows optimized boxed representation that avoids allocation)
  DataStruct // compatible constructors (all raw or regular types) and possibly singletons (need tag)
  // non-value types
  DataSingle(hasSingletons: bool) // only one constructor (no tag needed), hasSingletons true if it is a singleton as well
  DataAsMaybe // one constructor with one (non-recursive) field, and one singleton
  DataAsList // one constructor with fields, and one singleton (don't need a tag, for example can distinguish pointer vs enum)
  DataSingleNormal // one constructor with fields, and multiple singletons (distinguish one pointer vs enums)
  DataNormal(hasSingletons: bool)
  DataOpen;

fun show(d: dataRepr): string
  match d
    DataEnum -> "DataEnum"
    DataIso -> "DataIso"
    DataSingleStruct -> "DataSingleStruct"
    DataStructAsMaybe -> "DataStructAsMaybe"
    DataStruct -> "DataStruct"
    DataSingle(b) -> "DataSingle(" ++ b.show ++ ")"
    DataAsMaybe -> "DataAsMaybe"
    DataAsList -> "DataAsList"
    DataSingleNormal -> "DataSingleNormal"
    DataNormal(b) -> "DataNormal(" ++ b.show ++ ")"
    DataOpen -> "DataOpen"

type conRepr
  ConEnum(n: name, repr: dataRepr, vrepr: valueRepr, tag: int) // part of enumeration (none has fields)
  ConIso(n: name, repr: dataRepr, vrepr: valueRepr, tag: int) // one constructor with one field
  ConSingleton(n: name, repr: dataRepr, vrepr: valueRepr, tag: int) // constructor without fields (and not part of an enum)
  ConSingle(n: name, repr: dataRepr, vrepr: valueRepr, ctxPath: ctxPath, tag: int) // there is only one constructor and it is not iso or singleton (and this is it)
  ConAsJust(n: name, repr: dataRepr, vrepr: valueRepr, asNothing: name, tag: int) // constructor is the just node of a maybe-like datatype  (only use for DataAsMaybe, not for DataStructAsMaybe)
  ConStruct(n: name, repr: dataRepr, vrepr: valueRepr, tag: int) // constructor as value type
  ConAsCons(n: name, repr: dataRepr, vrepr: valueRepr, asNil: name, ctxPath: ctxPath, tag: int) // constructor is the cons node of a list-like datatype  (may have one or more fields)
  ConOpen(n: name, repr: dataRepr, vrepr: valueRepr, ctxPath: ctxPath) // constructor of open data type
  ConNormal(n: name, repr: dataRepr, vrepr: valueRepr, ctxPath: ctxPath, tag: int); // a regular constructor

fun show(r: conRepr): string
  match r
    ConEnum(n, drepr, vrepr, tag) -> "ConEnum(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ tag.show ++ ")"
    ConIso(n, drepr, vrepr, tag) -> "ConIso(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ tag.show ++ ")"
    ConSingleton(n, drepr, vrepr, tag) -> "ConSingleton(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ tag.show ++ ")"
    ConSingle(n, drepr, vrepr, ctxPath, tag) -> "ConSingle(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ show(ctxPath) ++ "," ++ tag.show ++ ")"
    ConAsJust(n, drepr, vrepr, asNothing, tag) -> "ConAsJust(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ asNothing.show ++ "," ++ tag.show ++ ")"
    ConStruct(n, drepr, vrepr, tag) -> "ConStruct(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ tag.show ++ ")"
    ConAsCons(n, drepr, vrepr, asNil, ctxPath, tag) -> "ConAsCons(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ asNil.show ++ "," ++ show(ctxPath) ++ "," ++ tag.show ++ ")"
    ConOpen(n, drepr, vrepr, ctxPath) -> "ConOpen(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ show(ctxPath) ++ ")"
    ConNormal(n, drepr, vrepr, ctxPath, tag) -> "ConNormal(" ++ n.show ++ "," ++ show(drepr) ++ "," ++ show(vrepr) ++ "," ++ show(ctxPath) ++ "," ++ tag.show ++ ")"

type ctxPath
  CtxNone
  CtxField(name: tName)

fun show(p: ctxPath): string
  match p
    CtxNone -> "CtxNone"
    CtxField(name) -> "CtxField(" ++ name.show ++ ")"

// Value data is not heap allocated and needs no header
fun hasCtxPath(repr: conRepr): bool
  repr.ctxPath.is-just

fun ctxPath(repr: conRepr): maybe<ctxPath>
  if repr.isValue then Nothing 
  else match repr
    ConSingle(ctxPath=cpath) -> Just(cpath)
    ConAsCons(ctxPath=cpath) -> Just(cpath)
    ConNormal(ctxPath=cpath) -> Just(cpath)
    ConOpen(ctxPath=cpath) -> Just(cpath)
    _ -> Nothing

fun scanCount(repr: conRepr)
  syntax/scanCount(repr.vrepr)

fun allocSize(c: conRepr, p: platform)
  c.allocSizeScan(p).fst

fun allocSizeScan(c: conRepr, p: platform)
  val (size, scan) = p.sizeScan(c.vrepr)
  if c.isValue then (0, scan) else (size, scan)

fun isValue(d: dataRepr): bool
  match d
    DataEnum -> True
    DataIso -> True
    DataSingleStruct -> True
    DataStructAsMaybe -> True
    DataStruct -> True
    _ -> False

fun needsTagField(d: dataRepr): bool
  match d
    DataStruct -> True
    DataStructAsMaybe -> True
    _ -> False

fun isValue(c: conRepr): bool
  c.repr.isValue

fun isValue(d: dataInfo): bool
  d.def.isValue

fun conRepr(d: dataInfo, c: conInfo)
  val (_, creprs) = d.dataRepr(fn(d') d'.isValue)
  match d.constrs.zip(creprs).filter(fn((a, _)) a.name == c.name).map(snd)
    [crepr] -> crepr
    _ -> throw("core/core: conRepr: constructor not in the datatype")

fun dataRepr(i: dataInfo, isVal: (dataInfo) -> bool): exn (dataRepr, list<conRepr>)
  val typeName = i.name
  val conInfos = i.constrs
  val tags = list(0, conInfos.length - 1)
  val singletons = conInfos.filter(fn(c) c.params.is-nil)
  val hasExistentials = conInfos.any(fn(c) c.existentials.is-cons)
  val isValue = isVal(i) && !i.isRec
  val (dataRepr, conReprFuns) = 
    if i.isRec then (DataOpen, conInfos.map(fn(ci) fn(ctag) ConOpen(typeName, DataOpen, ci.valueRepr, CtxNone)))
    elif conInfos.length == 1 then
      val conInfo = conInfos.head.unjust
      val dataRepr = 
        if isValue && conInfo.params.length == 1 then DataIso
        elif isValue && singletons.is-nil && !i.isRec then DataSingleStruct
        else DataSingle(singletons.is-cons)
      (dataRepr, [if isValue && conInfo.params.length == 1 then fn(tag) ConIso(typeName, dataRepr, conInfo.valueRepr, tag)
                  elif singletons.length == 1 then fn(tag) ConSingleton(typeName, dataRepr, conInfo.valueRepr, tag)
                  else fn(tag) ConSingle(typeName, dataRepr, conInfo.valueRepr, CtxNone, tag)])
    elif isValue && !i.isRec then
      val dataRepr = if conInfos.length == 2 && singletons.length == 1 && conInfos.filter(fn(c) c.params.length == 1).length == 1 then DataStructAsMaybe else DataStruct
      (dataRepr, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, dataRepr, c.valueRepr, tag) else fn(tag) ConStruct(typeName, dataRepr, c.valueRepr, tag)))
    else
      if conInfos.length == 2 && singletons.length == 1 then
        // note: for now we can only handle a true maybe type with a single Just constructor
        // with a parametric type so it is always kk_box_t at runtime.
        val maybeLike = match conInfos.filter(fn(c) c.params.length == 1)
          [cinfo] -> match cinfo.params
            [(_, TVar)] -> True // single field of type 'a
            _ -> False
          _ -> False
        if !i.isRec && maybeLike then
          (DataAsMaybe, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, DataAsMaybe, c.valueRepr, tag) else fn(tag) ConAsJust(typeName, DataAsMaybe, c.valueRepr, singletons.head.unjust.name, tag)))
        else (DataAsList, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, DataAsList, c.valueRepr, tag) else fn(tag) ConAsCons(typeName, DataAsList, c.valueRepr, singletons.head.unjust.name, CtxNone, tag)))
      else
        val dataRepr = if singletons.length == conInfos.length - 1 || conInfos.is-nil then DataSingleNormal else DataNormal(singletons.is-cons)
        (dataRepr, conInfos.map(fn(c) if c.params.is-nil then fn(tag) ConSingleton(typeName, dataRepr, c.valueRepr, tag) else fn(tag) ConNormal(typeName, dataRepr, c.valueRepr, CtxNone, tag)))
  (dataRepr, conReprFuns.map-indexed(fn(index, c) c(index + 1)))


// Definition Groups
alias defGroups = list<defGroup>

fun flatten(dgs: list<defGroup>): list<def>
  dgs.map(fn(d) match d {DefRec(dfs) -> dfs; DefNonRec(d) -> [d]}).concat()

fun flatten(dgs: list<defGroups>): list<def>
  dgs.map(flatten).concat()

fun flatten(dg: defGroup): list<def>
  match dg
    DefRec(defs) -> defs 
    DefNonRec(d) -> [d]

fun map(dg: defGroup, f: (def) -> e def): e defGroup
  match dg
    DefRec(defs) -> DefRec(defs.map(f))
    DefNonRec(d) -> DefNonRec(f(d))

type defGroup
  DefRec(defs: list<def>)
  DefNonRec(d: def)

fun show(d: defGroup): div string
  match d
    DefRec(defs) -> "DefRec(" ++ defs.show-list(show) ++ ")"
    DefNonRec(d') -> "DefNonRec(" ++ d'.show ++ ")"

// A value definition
struct def
  defName: name
  ktype: ktype
  defExpr: expr
  vis: visibility // private public
  sort: defSort // fun / val / var
  kinline: defInline // auto / always, never
  nameRange: range
  doc: string;

fun show(d: def): div string
  "Def(" ++ d.defName.show ++ "," ++ d.ktype.show ++ "," ++ d.defExpr.show ++ "," ++ d.vis.show ++ "," ++
  d.sort.show ++ "," ++ d.kinline.show ++ "," ++ d.nameRange.showFullRange ++ "," ++ d.doc.show ++ ")"

struct inlineDef
  defName: name
  expr: expr
  rec: bool
  kind: defInline
  cost: int
  sort: defSort // for borrow information
  paramSpecialize: list<bool>

fun isVal(d: def): bool
  !d.sort.is-defFun

fun paramInfos(d: def)
  match d.sort
    DefFun(i) -> i
    _ -> Nil

fun isSpecialize(inl: inlineDef)
  inl.paramSpecialize.is-cons

effect uniquePhase
  fun getUnique(): int
  fun setUnique(i: int): ()
  fun updateUnique(f: (int) -> int): int

fun runUniquePhase(start: int, f: () -> <uniquePhase|e> a): e a 
  var u := start
  with handler
    fun getUnique() u
    fun setUnique(i) u := i
    fun updateUnique(g) 
        u := g(u)
        u
  f()

effect corePhase
  fun getCoreDefs(): defGroups
  fun setCoreDefs(dgs: defGroups): ()
  fun phaseError(s: string): a

fun newUnique(): <uniquePhase> int
  updateUnique(fn(i) i + 1)

fun uniques(n: int): <uniquePhase> list<int>
  list(1, n).map(fn(_) newUnique())

fun uniqueId(s: string): <uniquePhase> id
  genId(s, newUnique())

fun uniqueIds(s: string, n: int): <uniquePhase> list<id>
  uniques(n).map(fn(i) genId(s, i))

fun uniqueName(s: string): <uniquePhase> name
  newHiddenName(s ++ "." ++ newUnique().show)

fun uniqueNameFrom(nm: name): <uniquePhase> name
  newUnique().toUniqueName(nm)

// Expressions
// Since this is System-F, all binding sites are annotated with their type.
type expr
  // Core lambda calculus
  Lam(names: list<tName>, eff: ktype, e: expr)
  Var(n: tName, info: varInfo) // typed name and possible typeArity/parameter arity tuple for top-level functions
  App(f: expr, args: list<expr>) // always fully applied!
  TypeLam(args: list<typeVar>, e: expr) // Type (universal) abstraction/application
  TypeApp(f: expr, types: list<ktype>)
  // Literals, constants and labels
  Con(n: tName, repr: conRepr) // typed name and its representation
  ELit(lit: lit)
  // Let
  Let(defs: list<defGroup>, e: expr)
  // Case expressions
  Case(exprs: list<expr>, branches: list<branch>);

fun show(e0: expr): div string
  match e0
    Lam(names, eff, e) -> "Lam(" ++ names.show-list(show) ++ "," ++ eff.show ++ "," ++ e.show ++ ")"
    Var(n, info) -> "Var(" ++ n.show ++ "," ++ info.show ++ ")"
    App(f, args) -> "App(" ++ f.show ++ "," ++ args.show-list(show) ++ ")"
    TypeLam(args, e) -> "TypeLam(" ++ args.show-list(show) ++ "," ++ e.show ++ ")"
    TypeApp(f, types) -> "TypeApp(" ++ f.show ++ "," ++ types.show-list(show) ++ ")"
    Con(n, repr) -> "Con(" ++ n.show ++ "," ++ repr.show ++ ")"
    ELit(lit) -> "ELit(" ++ lit.show ++ ")"
    Let(defs, e) -> "Let(" ++ defs.show-list(show) ++ "," ++ e.show ++ ")"
    Case(exprs, branches) -> "Case(" ++ exprs.show-list(show) ++ "," ++ branches.show-list(show) ++ ")"

struct branch
  patterns: list<pattern> // length = length exprs in the match
  guards: list<guard>; // any number (>= 1) of guarded expressions

fun show(b: branch): div string
  "Branch(" ++ b.patterns.show-list(show) ++ "," ++ b.guards.show-list(show) ++ ")"

struct guard
  test: expr // boolean
  body: expr; // body of the branch

fun show(g: guard): div string
  "Guard(" ++ g.test.show ++ "," ++ g.body.show ++ ")"

type pattern
  PatCon
    patName: tName // names the constructor with full signature.
    pattern: list<pattern> // sub-patterns. fully materialized to match arity.
    repr: conRepr // representation of ctor in backend.
    typeArgs: list<ktype> // zipped with patConPatterns
    kexists: list<typeVar> // closed under existentials here
    typeRes: ktype // result type
    info: conInfo // other constructor info
    skip: bool // skip testing for this constructor (as it should match already)
  PatVar(varName: tName, pattern: pattern) // name / type of variable and named subpattern
  PatLit(lit: lit)
  PatWild

fun show(p: pattern): div string
  match p
    PatCon(name, pattern, repr, typeArgs, kexists, typeRes, info, skip) -> 
      "PatCon(" ++ name.show ++ "," ++ pattern.show-list(show) ++ "," ++ repr.show ++ "," ++ 
      typeArgs.show-list(show) ++ "," ++ kexists.show-list(show) ++ "," ++ typeRes.show ++ "," ++ info.show ++ "," ++ skip.show ++ ")"
    PatVar(name, pattern) -> "PatVar(" ++ name.show ++ "," ++ pattern.show ++ ")"
    PatLit(lit) -> "PatLit(" ++ lit.show ++ ")"
    PatWild -> "PatWild"

type lit
  LitInt(i: int)
  LitFloat(d: float64)
  LitChar(c: string)
  LitString(s: string)

fun show(l: lit): string
  match l
    LitInt(i) -> "LitInt(" ++ i.show ++ ")"
    LitFloat(d) -> "LitFloat(" ++ d.show ++ ")"
    LitChar(c) -> "LitChar(" ++ c.show ++ ")"
    LitString(s) -> "LitString(" ++ s.show ++ ")"

type varInfo
  InfoNone
  InfoArity(t: int, p: int) // type parameters, parameters
  InfoExternal(b: list<(target, string)>) // inline body
  InfoReuse(p: pattern) 
  InfoConField(cName: tName, repr: conRepr, fName: tName) // constructor name, field name

value struct tName
  getName: name
  tNameType: ktype

fun (==)(tn1: tName, tn2: tName): bool
  tn1.getName == tn2.getName

fun show(n: tName): string
  n.getName.show

fun defTName(d: def): tName
  TName(d.defName, d.ktype)

fun defsTNames(defs: list<def>): list<tName>
  defs.map(defTName)

fun defGroupTNames(dg: defGroup): list<tName>
  match dg
    DefRec(defs) -> defsTNames(defs)
    DefNonRec(d) -> [defTName(d)]

fun defGroupsTNames(dgs: list<defGroup>): list<tName>
  dgs.map(defGroupTNames).concat()

fun show(v: varInfo): string
  match v
    InfoNone -> ""
    InfoReuse -> "reuse:<pat>"
    InfoConField(n, _, fName) -> "field: " ++ n.show ++ "." ++ fName.show
    InfoArity(m, n) -> "arity:" ++ m.show ++ "," ++ n.show
    InfoExternal(b) -> "external:" ++ b.show-list(fn((t, s)) t.show ++ ":" ++ s)

fun airity(v: varInfo): int
  match v
    InfoArity(_, n) -> n
    _ -> 0

fun typeAirity(v: varInfo): int
  match v
    InfoArity(n, _) -> n
    _ -> 0

fun isLocal(i: varInfo): bool
  match i
    InfoNone -> True
    InfoReuse -> True
    _ -> False

fun isRefCounted(i: varInfo)
  i.isLocal

fun isTotal(e: expr): div bool
  match e
    Lam -> True
    Var -> True
    TypeLam(_, ex) -> ex.isTotal
    TypeApp(ex, _) -> ex.isTotal
    Con -> True
    ELit -> True
    Let(dgs, ex) -> dgs.flatten.all(isTotal) && ex.isTotal
    Case(exps, brnchs) -> exps.all(isTotal) && brnchs.all(isTotal)
    App(f, args) -> f.isTotal && args.all(isTotal)

fun isTotal(b: branch): div bool
  b.guards.all(isTotal)

fun isTotal(g: guard): div bool
  g.body.isTotal

fun isTotalFun(e: expr): pure bool
  match e
    Lam(_, _, b) -> b.isTotal
    TypeLam(_, ex) -> ex.isTotalFun
    TypeApp(ex, _) -> ex.isTotalFun
    Con -> True
    ELit -> True
    Let(dgs, e1) -> dgs.flatten.all(isTotal) && e1.isTotalFun
    Case(exps, brnchs) -> exps.all(isTotalFun) && brnchs.all(isTotalFun)
    App(f, args) -> e.typeOf.hasTotalEffect && f.isTotalFun && args.all(isTotal)
    Var(v) -> v.getName == nameBox || v.getName == nameUnbox

fun isTotalFun(b: branch): pure bool
  b.guards.all(isTotalFun)

fun isTotalFun(g: guard): pure bool
  g.body.isTotalFun

fun isTotal(d: def): div bool
  d.defExpr.isTotal

fun hasTotalEffect(tp: ktype): bool
  match tp.splitFunScheme
    Nothing -> False
    Just((_, _, _, eff, _)) -> eff.isTypeTotal

fun isMonType(tp: ktype): pure bool
  if tp.kind == kindEffect then tp.isMonEffect
  else match tp.expandSyn
    TForAll(_, _, t) -> t.isMonType
    TFun(_, eff, _) -> eff.isMonEffect
    _ -> False

fun isMonEffect(eff: ktype): pure bool
  val (ls, tl) = eff.extractEffectExtend
  !tl.isEffectEmpty || ls.any(fn(l) match l.getHandledEffect([]) {Just((ResumeMany, _)) -> True; _ -> False})

fun isInlineable(max: int, d: def): div bool
  match d.kinline
    InlineAlways -> True
    InlineNever -> False
    _ -> d.cost <= max

val costInf = 1000

fun cost(d: def): div int
  val n = d.costLocal
  if d.isVal then if n == 0 then 0 else costInf else n

fun costLocal(d: def): div int
  d.defExpr.cost

fun cost(dg: defGroup): div int
  match dg
    DefRec(defs) -> defs.map(cost).sum
    DefNonRec(def) -> cost(def)

fun cost(e0: expr): div int
  match e0
    Var(tn) | tn.getName.isHiddenExternalName -> costInf
    Lam(_, _, b) -> 0 + b.cost
    Var -> 0
    App(e, args) -> 1 + e.cost + args.map(cost).sum
    TypeLam(_, e) -> e.cost
    TypeApp(e, _) -> e.cost
    Con -> 0
    ELit -> 0
    Let(dgs, b) -> dgs.map(cost).sum + b.cost
    Case(exprs, branches) -> (branches.length - 1) + exprs.map(cost).sum + branches.map(cost).sum

fun cost(b: branch): div int
  b.guards.map(cost).sum

fun cost(g: guard): div int
  g.body.cost

fun typeArity(e: expr): pure int
  e.typeOf.typeArities.fst

fun paramArity(e: expr): pure int
  e.typeOf.typeArities.snd

fun getEffect(e: expr): keffect
  match e
    Lam(_, eff, _) -> eff
    TypeLam(_, Lam(_, eff, _)) -> eff
    _ -> effectEmpty

// Generic traversals

// fun foldMap(e: expr, acc: expr -> e ctx<a>): e ctx<a>
//   match e
//     Lam(_, _, b) -> acc(e) ++ foldMap(b, acc)
//     Var -> acc(e)
//     App(f, args) -> args.foldl(acc(e) ++ foldMap(f, acc), fn(s, a) s ++ acc(a))
//     TypeLam(_, b) -> acc(e) ++ foldMap(b, acc)
//     TypeApp(f, _) -> acc(e) ++ foldMap(f, acc)
//     Con -> acc(e)
//     ELit -> acc(e)
//     Let(binders, body) -> binders.flatten.foldl(acc(e), fn(s, a) s ++ acc(a.expr)) ++ foldMap(body, acc)
//     Case(cases, branches) -> branches.foldl(cases.foldl(acc(e), fn(s, a) s ++ acc(a)), fn(s, b) b.guards.foldl(s, fn(s', g) s' ++ acc(g.test) ++ acc(g.expr)))

// effect efind
//   final ctl found(e: expr): a

// fun anySubExpr(e, f)
//   with handler 
//     final ctl found(ex) Just(ex)
//     return(x) Nothing
//   val c = ctx _
//   e.foldMap(fn(a) if f(a) then found(e) else c)


// TODO: More here

// Type variables
val tnamesEmpty = linearSet([], fn(a, b) a.getName == b.getName, fn(a) a.show)
fun tnames(l: list<tName>): linearSet<tName>
  linearSet(l, fn(a, b) a.getName == b.getName, fn(a) a.show)

fun (>)(t1: tName, t2: tName): bool
  name/compare(t1.getName, t2.getName) == Gt

fun makeLet(defs: list<defGroup>, expr: expr): expr
  match defs
    Nil -> expr
    _ -> match expr
      Let(defs', body) -> Let(defs ++ defs', body)
      _ -> Let(defs, expr)

fun makeTypeApp(e: expr, l: list<ktype>): expr
  match l
    Nil -> e
    _ -> match e
      TypeApp(e1, l') -> TypeApp(e1, l ++ l')
      _ -> TypeApp(e, l)

fun addApps(l: list<expr>, e: expr)
  match l
    Nil -> e
    _ -> match e
      App(e1, l') -> App(e1, l ++ l')
      _ -> App(e, l)

fun addTypeApps(l: list<typeVar>, e: expr)
  match l
    Nil -> e
    _ -> match e
      TypeApp(e', l') -> TypeApp(e', l' ++ l.map(TVar))
      _ -> TypeApp(e, l.map(TVar))

fun addTypeLambdas(l: list<typeVar>, e: expr)
  match l
    Nil -> e
    _ -> match e
      TypeLam(l', e') -> TypeLam(l ++ l', e')
      _ -> TypeLam(l, e)

fun addLambdas(l: list<(name, ktype)>, effT: ktype, e: expr)
  match l
    Nil -> e
    _ -> match e
      Lam(l', _, e') -> Lam(l.map(fn((n, t)) TName(n, t)) ++ l', effT, e')
      _ -> Lam(l.map(fn((n, t)) TName(n, t)), effT, e)

fun addLambdas(l: list<tName>, effT: ktype, e: expr)
  match l
    Nil -> e
    _ -> match e
      Lam(l', _, e') -> Lam(l ++ l', effT, e')
      _ -> Lam(l, effT, e)

fun addNonRec(x: name, tp: ktype, e: expr, e': expr)
  Let([DefNonRec(Def(x, tp, e, Private, if e.isValue then DefVal else DefFun([]), InlineAuto, rangeNull, ""))], e')

fun isValue(e: expr): bool
  match e
    TypeLam(_, Lam) -> False
    Lam -> False
    _ -> True

fun addCoreDef(c: core, d: def): core
  c(defs = c.defs ++ [DefNonRec(d)])

fun coreNull(n: name)
  Core(n)

fun freshName(pfx: string)
  newName(pfx ++ "." ++ getUnique().show)

fun hasNoEffect(e: expr)
  match e
    TypeApp(e) -> e.hasNoEffect
    ELit -> True
    Con -> True
    _ -> False

fun openEffect(effFrom: keffect, effTo: keffect, tpFrom: ktype, tpTo: ktype, expr: expr)
  if expr.hasNoEffect then expr
  else
    val a = TypeVar(-1, kindStar, Bound)
    val b = TypeVar(-2, kindStar, Bound)
    val e1 = TypeVar(-3, kindEffect, Bound)
    val e2 = TypeVar(-4, kindEffect, Bound)
    val tpOpen = TForAll([e1, e2, a, b], [], TFun([(newName("x"), tpFrom)], typeTotal, tpTo))
    val varOpen = Var(TName(nameEffectOpen, tpOpen), InfoExternal([(DefaultTarget, "#1")]))
    App(TypeApp(varOpen, [effFrom, effTo, tpFrom, tpTo]), [expr])

fun makeInt32(i: int): expr
  val int32 = Var(TName(nameInt32, TFun([(nameNil, typeInt)], typeTotal, typeInt32)), InfoArity(1, 0))
  App(int32, [ELit(LitInt(i))])

fun makeEvIndex(i: int)
  if i < 0 then throw("core/core makeEvIndex: size_t < 0 " ++ i.show)
  val sizet = Var(TName(nameSSizeT, TFun([(nameNil, typeInt)], typeTotal, typeEvIndex)), InfoArity(1, 0))
  App(sizet, [ELit(LitInt(i))])

fun makeSizeT(i: int)
  if i < 0 then throw("core/core makeSizeT: size_t < 0 " ++ i.show)
  val sizet = Var(TName(nameSSizeT, TFun([(nameNil, typeInt)], typeTotal, typeSSizeT)), InfoArity(1, 0))
  App(sizet, [ELit(LitInt(i))])

fun typeOf(d: def): ktype
  d.ktype

fun typeOf(tn: tName): ktype
  tn.tNameType

fun typeOf(expr: expr): pure ktype
  match expr
    Lam(pars, eff, expr) -> TFun(pars.map(fn((TName(name, tp))) (name, tp)), eff, expr.typeOf)
    Var(tn) -> typeOf(tn)
    Con(tn) -> typeOf(tn)
    App(f, args) -> match f.typeOf.splitFunScheme
      Just((_, _, targs, eff, tres)) 
        | args.length == targs.length || targs.length == 0 -> tres
        | args.length > targs.length -> typeOf(App(Var(TName("tmp".newName, tres), InfoNone), args.drop(targs.length)))
        | True -> TFun(targs.drop(args.length), eff, tres)
      _ -> throw("core/core typeOf(App..) Expected function TODO: Show real type")
    TypeLam(xs, e) -> TForAll(xs, [], e.typeOf)
    TypeApp(e, []) -> e.typeOf
    // TypeApp(expr, tps) ->
    //   val (tvs, tp1) = expr.typeOf.splitTForall
    //   tvs.zip(tps).subNew(tp1)
    ELit(l) -> l.typeOf
    Let(_, e) -> e.typeOf
    Case(_, branches) -> branches.head.unjust.typeOf

fun typeOf(Branch(_, guards): branch): pure ktype
    match guards
      Cons(g, _) -> g.typeOf
      _ -> throw("core/core typeOf(Branch..) branch with no guards")

fun typeOf(Guard(_, expr): guard): pure ktype
  expr.typeOf

fun typeOf(l: lit): ktype
  match l
    LitInt(_) -> typeInt
    LitFloat(_) -> typeFloat
    LitChar(_) -> typeChar
    LitString(_) -> typeString

fun extractSignatures(es: externals): list<ktype>
  match es
    Cons(External(visibility=Public, typeScheme=t), rst) -> Cons(t, extractSignatures(rst))
    Cons(_, rst) -> extractSignatures(rst)
    Nil -> Nil

fun extractSignatures(d: defGroups): list<ktype>
  d.flatten.map(fn(d') d'.ktype)

fun extractSignatures(c: core): list<ktype>
  extractSignatures(c.externals) ++ extractSignatures(c.defs)

fun splitFun(tp: ktype): <exn> (list<(name, ktype)>, ktype)
  match tp.expandSyn
    TFun(args, _, res) -> (args, res)
    _ -> throw("core/core splitFun: expected function type")

fun splitTForAll(tp: ktype): <exn> (list<typeVar>, ktype)
  match tp.expandSyn
    TForAll(tvs, _, t) -> (tvs, t)
    _ -> throw("core/core splitTForAll: expected forall type")

alias deps = linearSet<name>
fun depsUnions(l: list<deps>): deps
  l.foldl(namesEmpty, fn(s: deps, a: deps) s + a)
fun dep(t: tName): deps
  dep(t.getName)
fun dep(n: name): deps
  if n.isQualified then namesEmpty.add(n.qualifier) else namesEmpty

fun deps(l: list<inlineDef>, c: core): div deps
  depsUnions(l.map(fn(i) i.expr.dep)) + c.deps

fun deps(l: list<inlineDef>): div deps
  depsUnions(l.map(fn(i) i.expr.dep))

fun deps(c: core): div deps
  (depsUnions(c.defs.flatten.map(dep)) + depsUnions(c.typeDefs.flatten.map(dep)) + c.imports.filter(fn(i) i.visibility.is-public).map(fn(i) i.importName)) - c.coreName

fun dep(td: typeDef): div deps
  match td
    Synonym(info) -> info.t.dep
    Data(info) -> depsUnions(info.constrs.map(fn(c) c.typeScheme.dep))

fun dep(t: ktype): div deps
  match t
    TForAll(_, _, rho) -> rho.dep
    TFun(args, eff, res) -> depsUnions(Cons(eff.dep, args.map(fn((_, t')) t'.dep))) + res.dep
    TCon(tc) -> tc.name.dep
    TVar -> namesEmpty
    TApp(tp, tps) -> tp.dep + depsUnions(tps.map(dep))
    TSyn(_, args, tp) -> tp.dep + depsUnions(args.map(dep))

fun dep(d: def): div deps
  depsUnions([d.ktype.dep, d.defExpr.dep])

fun dep(e: expr): div deps
  match e
    Var(tn) -> tn.dep
    Lam(_, eff, body) -> eff.dep + body.dep
    App(e, args) -> depsUnions(Cons(e.dep, args.map(dep)))
    TypeLam(_, body) -> body.dep
    TypeApp(e, tps) -> e.dep + depsUnions(tps.map(dep))
    Con(tn) -> tn.dep
    ELit(_) -> namesEmpty
    Let(defs, body) -> depsUnions(Cons(body.dep, defs.flatten.map(dep)))
    Case(exprs, branches) -> depsUnions(exprs.map(dep) ++ branches.map(dep))

fun dep(b: branch): div deps
  depsUnions(b.patterns.map(dep)) + depsUnions(b.guards.map(dep))

fun dep(g: guard): div deps
  g.body.dep

fun dep(p: pattern): div deps
  match p
    PatCon(tn, pats) -> tn.dep + depsUnions(pats.map(dep))
    PatVar(_, p) -> p.dep
    _ -> namesEmpty